= Chatbot Workshop

Copyright (c) 2018 https://www.fihlon.ch/[Marcus Fihlon]

== Prerequesites

- Java 8
- Java IDE
- You should be familiar with your IDE
- You need your own Telegram account
- You need Telegram installed on your mobile or desktop

== Register

Use Telegram to talk to the `BotFather` to register a new bot. Write down your bot username and your bot token.

== Project setup

For this workshop we use gradle. Please create a new gradle project using your IDE.

== Getting started

=== Dependencies

To use the Telegram Bot API, please add the following dependency:

```groovy
compile group: 'org.telegram', name: 'telegrambots', version: '3.6'
```

=== Create a bot class

Create a class `GettingStartedBot` that extends `TelegramLongPollingBot` and add empty methods to satisfy the class contract:

```java
public class GettingStartedBot extends TelegramLongPollingBot {

  @Override
  public String getBotUsername() {
    return null;
  }

  @Override
  public String getBotToken() {
    return null;
  }

  @Override
  public void onUpdateReceived(final Update update) {
  }

}
```

=== Bot username

The first method must return the username of your bot you wrote down while you registered your bot:

```java
@Override
public String getBotUsername() {
  return "MyWorkshopBot";
}
```

=== Bot token

As you might imagine, the second method has to return the token of your bot. The token is needed for identification, like a password, so keep it private and *do not* commit it to any registry:

```java
@Override
public String getBotToken() {
  return "1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ";
}
```

=== React on a message

In the third method you write your code which will be executed when your bot receives a message. For uour first example we will just send the same message back to the sender:

```java
@Override
public void onUpdateReceived(final Update update) {
  if (update.hasMessage() && update.getMessage().hasText()) {
    final Long chatId = update.getMessage().getChatId();
    final String text = update.getMessage().getText();
    final SendMessage message = new SendMessage()
        .setChatId(chatId)
        .setText(text);
    try {
      execute(message);
    } catch (final TelegramApiException e) {
      e.printStackTrace();
    }
  }
}
```

This example should be quite easy to understand. First, we check if we have a message and it is a text message. Then we extract two values:

. The `chatId`, which identifies a chat. We need this id, to send the answer to the correct person. Every chat has a unique id. We could save this id for later use and reply at any time. But here, we reply immediately.
. The text. This is just the text of the message, the bot received.

To send an answer, we have to create a `SendMessage` method and set the `chatId` and the text, which should be send. Then we `excute` this method, which will send the message. Of course, there can happen a lot of errors (servers down, network failures etc), so have to do really good error handling like in the example above.

=== Start your bot

For our simple example, we just a good old `main` method. The start needs four steps:

. We need a Telegram API context
. We need an instance of the Telegram API
. We need an instance of our bot
. We need to register our bot instance at Telegram

```java
public static void main(final String[] args) throws TelegramApiRequestException {
  ApiContextInitializer.init();                          // 1
  final TelegramBotsApi api = new TelegramBotsApi();     // 2
  final GettingStartedBot bot = new GettingStartedBot(); // 3
  api.registerBot(bot);                                  // 4
}
```

=== Play with your bot

Now, start your bot by running your `main` method.

_Congratulations!_

== Thinking in Abilities

// TODO describe the ability feature of the Telegram Bot API

=== Dependencies

To use the Telegram Bot Ability API, please add the following dependency:

```groovy
compile group: 'org.telegram', name: 'telegrambots-abilities', version: '3.6'
```

=== Create a bot class

Create a class `WorkshopBot` that extends `AbilityBot` and add a no argument constructor and empty methods to satisfy the class contract:

```java
public class WorkshopBot extends AbilityBot {

  public WorkshopBot() {
    super(null, null);
  }

  @Override
  public int creatorId() {
    return 0;
  }
}
```

=== Bot token and username

The easy part: Add the token and username of your bot as constants to your class and specify them in the super constructor call:

```java
public class WorkshopBot extends AbilityBot {

  private static String BOT_TOKEN = "381467743:AAGJAtBZpqcqFHRFcSfzd3LZZTlYKf674ow";
  private static String BOT_USERNAME = "McPringleBot";

  public WorkshopBot() {
    super(BOT_TOKEN, BOT_USERNAME);
  }

  …
}
```

=== Your Telegram ID

AbilityBot forces a single implementation of creator ID. This ID corresponds to you, the bot developer. The bot needs to know its master since it has sensitive commands that only the master can use. So, if your Telegram ID Is 123456789, then add the following method:

```java
@Override
public int creatorId() {
  return 123456789;
}
```

If you do not know your Telegram ID, just start a chat to the `userinfobot`.

=== Say hello

Should be easy: Let's say hello. For creating an ability, we use the builder pattern:

```java
public Ability sayHelloWorld() {
  return Ability
      .builder()
      .name("hello")                                                    // 1
      .info("says hello world")                                         // 2
      .locality(ALL)                                                    // 3
      .privacy(PUBLIC)                                                  // 4
      .action(context -> silent.send("Hello world!", context.chatId())) // 5
      .build();
}
```

. the name of the command
. a description of the command
. the location of the command (`ALL`, `USER`, `GROUP`)
. the privacy setting (`PUBLIC`, `GROUP_ADMIN`, `ADMIN`, `CREATOR`)
. the action to be executed

=== Start your bot

To start the ability bot we need to do exactly the same as with the bot, we created before:

. We need a Telegram API context
. We need an instance of the Telegram API
. We need an instance of our bot
. We need to register our bot instance at Telegram

```java
public static void main(final String[] args) throws TelegramApiRequestException {
  ApiContextInitializer.init();                      // 1
  final TelegramBotsApi api = new TelegramBotsApi(); // 2
  final WorkshopBot bot = new WorkshopBot();         // 3
  api.registerBot(bot);                              // 4
}
```

=== Play with your bot

Now, start your bot by running your `main` method and send the `/hello` command to your bot.

_Congratulations!_

Wait! Since you've implemented an ability bot, you get factory abilities as well. Try:

* `/commands` – Prints all commands supported by the bot.
        This will essentially print `hello - says hello world`. Yes! This is the information we supplied to the ability. The bot prints the commands in the format accepted by `BotFather`. So, whenever you change, add or remove commands, you can simply send `/commands` to your bot and forward that message to `BotFather`.
* `/claim` – Claims this bot
* `/backup` – returns a backup of the bot database
* `/recover` – recovers the database
* `/promote @username` – promotes user to bot admin
* `/demote @username` – demotes bot admin to user
* `/ban @username` – bans the user from accessing your bot commands and features
* `/unban @username` – lifts the ban from the user

== Replies

A reply is AbilityBot's swiss army knife. It comes in two variants and is able to handle all possible use cases.

=== Standalon Reply

Standalone replies do not need abilities. Lets add one to our bot:

```java
public Reply replyToPhoto() {
  return Reply.of(
      update -> silent.send("Nice pic!", getChatId(update)),
      Flag.PHOTO);
}
```

As you can see, you just provide a lambda function which consumes the update. In addition to the required lambda function, replies can have optional predicates. In our example we let the bot know, that we only want to reply to images. Take a look at the `Flag` enum.

Wow, that was easy! How easy would it be to implement a `VoxxedDaysBucharestBot`, where you can send pictures which are automatically uploaded to a Google Drive (or similar) share? If you are a nerd and finish this workshop early, try to implement it…

=== Ability Reply and own Predicates

In exactly the same manner, you are able to attach replies to abilities. This way you can localize replies that relate to the same ability.

```java
public Ability sayHi() {
  return Ability
    .builder()
    .name("hi")
    .info("says hi")
    .locality(ALL)
    .privacy(PUBLIC)
    .action(context -> {
      final String firstName = context.user().firstName();
      silent.send("Hi, " + firstName, context.chatId());
    })
    .reply(
        update -> silent.send("Wow, nice name!", update.getMessage().getChatId()),
        TEXT,
        update -> update.getMessage().getText().startsWith("/hi"),
        isMarcus()
    )
    .build();
}

private Predicate<Update> isMarcus() {
  return update -> update.getMessage().getFrom().getFirstName().equalsIgnoreCase("Marcus");
}
```

In this example you can see how easy it is to create and use your own predicates. Using predicates, you can implement all checks, so your logic keeps clean and can focus on action.

